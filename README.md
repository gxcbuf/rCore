## Rust实现操作系统

### Qemu模拟器
Qemu模拟器启动后，物理内存的起始位置为 `0x80000000`, 所以我们需要将要执行的代码加载至该地址处。

我们的启动流程大致分为三个阶段：
- 第一阶段：Qemu启动后会会将CPU的程序计数器设置为 `0x1000`，所以实际Qemu执行的第一条指令位于此处，
    接着它会执行几条指令，然后跳转到 `0x80000000`, 并进入第二阶段。
- 第二阶段：我们已经通过指令将bootloader(rustsbi-qemu.bin)放到 `0x80000000`位置处，所以
    进入第二阶段时，bootloader就负责接手，然后做一些初始化工作，跳转到 `0x80200000`，进入第三阶段
- 第三阶段：保证内核代码第一条指令位于 `0x80200000`，内核即可接手对计算机的控制。

真实计算机的加电启动流程也大致与上述阶段类似：
- 第一阶段：加电后CPU的PC寄存器被设置为ROM的内部地址，然后开始运行ROM处的软件，主要是做一些CPU的初始化
    将bootloader的代码、数据，从硬盘加载到物理内存，最后跳转到适当的地址，将控制权交给bootloader
- 第二阶段：bootloader同样会做一些初始化的工作，将操作系统从硬盘加载到物理内存，然后跳转到适当地址，
    将控制权交给操作系统。目前的bootloader已经非常复杂，它负责了很多硬件的处理，本质上也是一个操作系统
- 第三阶段：控制权移交给操作系统，由操作系统给我们提供服务。

### 程序内存布局

在源代被编译为可执行文件之后，我们可以根据其功能，将其进行划分，这种划分称之为**段(section)**，不同的段会编译器放到不同的位置上，这就构成了**内存布局**。
```
# 一种典型的内存布局
[low addr] .text --> .rodata --> .data --> .bss --> heap(堆) --> ... <-- stack(栈) [high addr]
```

- .text：代码段，用于存放程序的代码
- .rodata: 全局数据段，用于存放常数或者常量字符串
- .data: 全局数据段，用于存放可修改的全局数据
- .bss: 用于存放未初始化的全局数据，通常由程序加载代为初始化
- heap(堆)：用于存放程序运行时动态分配的数据，向高地址增长
- stack(栈)：用于函数调用上下文的保存与恢复，也用于存储函数的局部变量，向低地址增长

### 编译流程

1. 编译器(Complier) 将每个源文件从高级语言转化为汇编语言，此时仍是ASCII或其它编码的文本文件
2. 汇编器(Assembler) 将上一步每个源文件文本格式的指令转化为机器码，得到一个二进制的**目标文件**
3. 链接器(Linker) 将上一步得到的所以目标文件及一些外部文件链接在一起，得到一个文字的可执行文件

汇编器输出的每个目标文件都有自己独立的内存布局，链接器会将所有的目标文件整合成一个整体的内存布局，这个过程主要做两件事情：

1. 将不同目标文件的section在目标内存布局中重新排布，得到新的`.text, .rodata, .data, .bss, heap, stack`布局。
2. 将符号替换为具体地址。

> 编译后生成的ELF可执行文件，包含一部分metadata, 所以我们需要将其移除才能让内核正常执行
> 使用rust-objcopy --strip-all 可以移除可执行文件的元数据

### 特权级机制

为了保护操作系统不受出错应用程序的影响，单凭软件是很难做到的，而需要CPU提供一种特权级隔离机制，使得CPU在执行应用程序和操作系统内核指令时处于不同的特权级。为了保证操作系统的安全，对应用程序而言，主要需要限制两个方面：

1. 应用程序不能访问任意的地址空间
2. 应用程序不能执行某些可能破坏计算机系统的指令

为了让应用程序获得操作系统的函数服务，如果采用传统的函数调用(`call` `ret`)将会直接绕过硬件的特权级保护检查，所以设计了新的机器指令即**系统调用**：
**执行环境调用(`ecall`)** 和 **执行环境返回(`eret`)**

- ecall: 具有用户态到内核态的执行环境切换能力的函数调用指令
- eret: 具有内核态到用户态的执行环境切换能力的函数返回指令

在拥有这样的机制后，还需要操作系统能在执行`eret`前准备和恢复用户态执行应用程序的上下文，也需要在应用程序调用`ecall`后，能检查应用程序的系统调用参数，确保参数不会破坏操作系统。

#### RISC-V 特权级架构

| 级别 | 编码 | 名称                                  |
| ---- | ---- | ------------------------------------- |
| 0    | 00   | 用户/应用模式， (U, User/Application) |
| 1    | 01   | 监督模式 (S, Supervisor)              |
| 2    | 10   | 虚拟监督模式(H, Hypervisor)           |
| 3    | 11   | 机器模式 (M, Machine)                 |

#### RISC-V 特权指令

与特权级无关的一般指令和通用寄存器`x0 ~ x31`在任何特权级都能执行，而每个特权级都对应一些特殊指令和**控制状态寄存器(CSR)**。

> 如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常，这个错误一般是不可恢复的，此时执行环境会将低特权级的应用程序终止。

| 指令             | 含义                                            |
| ---------------- | ----------------------------------------------- |
| sret             | 从S模式返回U模式                                |
| wfi              | 处理器在空闲时进入低功耗状态等待中断            |
| sfence.vma       | 刷新TLB缓存                                     |
| 访问S模式CSR指令 | `sepc/stvec/scause/sscartch/stval/sstatus/satp` |

> #### RISC-V寄存器编号和别名
>
> | 寄存器      | 别名       |
> | ----------- | ---------- |
> | `x1`        | `ra`       |
> | `x2`        | `sp`       |
> | `x3`        | `gp`       |
> | `x4`        | `tp`       |
> | `x5 ~ x7`   | `t0 ~ t2`  |
> | `x8 ~ x9`   | `s0 ~ s1`  |
> | `x10 ~ x17` | `a0 ~ a7`  |
> | `x18 ~ x27` | `s2 ~ s11` |
> | `x28 ~ x31` | `t3 ~ t6`  |

#### RISC-V 特权级切换

- 进入S特权级Trap的相关CSR

| CSR     | 与Trap有关的功能                                           |
| ------- | ---------------------------------------------------------- |
| sstatus | SSP等字段给出Trap发生之前CPU处于哪个特权级                 |
| sepc    | 当Trap是一个异常时，记录Trap发生之前执行的最后一条指令地址 |
| scause  | Trap的原因                                                 |
| stval   | Trap的附加信息                                             |
| stvec   | 控制Trap处理代码的入口地址                                 |

当CPU执行完一条指令(如`ecall`)并准备从U特权级陷入(`Trap`)S特权级时，硬件会自动完成下面操作：

1. `sstatus`的`SPP`字段会被修改为CPU当前的特权级
2. `sepc`会被修改为Trap处理完后默认会执行的下一条指令的地址
3. `scause/stval`会被修改为这次Trap的原因以及相关的附加信息
4. CPU会跳转到`stvec`所设置的Trap处理入口地址，并将当前特权级设置为S，然后从Trap处理入口地址开始

当CPU完成Trap处理准备返回时，需要通过一条S特权级指令`sret`来完成，它具有下面功能：

1. CPU会将当前特权级按照`sstatus`的`SPP`字段设置为U或S
2. CPU会跳转到`sepc`寄存器执行的那条指令，然后继续执行



> 在Trap触发时，CPU就会切换特权级并跳转至相应的地址，但是我们必须保存原控制寄存器的状态，这一般通过内核栈来保存，我们需要专门为操作系统准备内核栈，而不是应用程序的用户栈，使用两个栈主要是为了保证操作的安全性。